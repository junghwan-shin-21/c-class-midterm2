name: C 프로그래밍 중간고사 (통합 채점)

on: [push]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v3

      - name: 통합 채점 스크립트 실행 (100점 만점)
        id: grading
        run: |
          # ANSI 색상 코드 정의
          GREEN='\033[32m'
          RED='\033[31m'
          BLUE='\033[34m'
          NC='\033[0m' # No Color

          # ----------------------------------------------------
          # 1. 초기 변수 설정
          # ----------------------------------------------------
          P1_SCORE=0
          P2_SCORE=0
          P1_FEEDBACK=""
          P2_FEEDBACK=""
          FINAL_SCORE=0

          # Normalize function: Remove all whitespace (spaces, tabs, newlines, carriage returns) for strict comparison.
          # 공백 및 줄바꿈 문자를 모두 제거하여 엄격하게 비교합니다.
          normalize_output() {
            tr -d ' \t\n\r' < "$1"
          }

          # ----------------------------------------------------
          # 2. 문제 1 채점 (N의 배수 출력 - main-1.c) - 50점
          # N을 입력받아 50까지의 배수를 출력합니다.
          # ----------------------------------------------------
          echo -e "\n${BLUE}--- [TEST P1] N의 배수 출력 채점 시작 (main-1.c) ---${NC}"
          INPUT_P1="8"
          EXPECTED_P1_LINE="8의 배수: 8 16 24 32 40 48" # 최종 기대 출력 라인

          # 2-1. 컴파일 시도
          if gcc main-1.c -o main1 2> compile_error_p1.txt; then
            echo -e "${GREEN}[OK]${NC} 문제 1: 컴파일 성공."
            
            # 2-2. 예상 출력 파일 생성 (줄바꿈 포함)
            printf "${EXPECTED_P1_LINE}\n" > expected_p1.txt
            
            # 2-3. 실행 및 원본 출력 캡처 (입력: 8)
            echo "$INPUT_P1" | ./main1 > actual_p1_raw.txt
            
            # 2-4. 출력 정리: '입력: ' 프롬프트와 불필요한 선행 문자를 제거하고 결과 라인만 추출
            # '8의 배수:' 키워드가 있는 라인을 찾아 그 시작점부터 추출
            grep "${INPUT_P1}의 배수:" actual_p1_raw.txt | tail -n 1 | sed "s/^.*${INPUT_P1}의 배수:/${INPUT_P1}의 배수:/" > actual_p1.txt

            # 2-5. 출력 비교
            if [[ "$(normalize_output actual_p1.txt)" == "$(normalize_output expected_p1.txt)" ]]; then
              P1_SCORE=50
              P1_FEEDBACK="${GREEN}[OK]${NC} 문제 1 (N의 배수): 통과 (50점)"
            else
              P1_FEEDBACK="${RED}[FAIL]${NC} 문제 1 (N의 배수): 실패. (입력: ${INPUT_P1})"
              P1_FEEDBACK="${P1_FEEDBACK}\n  [학생 출력]: $(cat actual_p1.txt | tr '\n' ' ')"
              P1_FEEDBACK="${P1_FEEDBACK}\n  [예상 출력]: (정규화 전: ${EXPECTED_P1_LINE})"
            fi
          else
            echo -e "${RED}[FAIL]${NC} 문제 1: 컴파일 실패."
            P1_FEEDBACK="${RED}[FAIL]${NC} 문제 1 (N의 배수): 컴파일 실패. 코드를 확인하세요."
          fi
          
          # ----------------------------------------------------
          # 3. 문제 2 채점 (합계, 최대값, 최소값 - main-2.c) - 50점
          # 10개 양의 정수 입력, 합/최대/최소 출력
          # ----------------------------------------------------
          echo -e "\n${BLUE}--- [TEST P2] 합계, 최대/최소값 채점 시작 (main-2.c) ---${NC}"
          INPUT_P2="10 20 5 80 15 30 75 40 50 25" # 양의 정수만 사용
          SUM_P2=350
          MAX_P2=80
          MIN_P2=5
          EXPECTED_P2_LINES="합계: ${SUM_P2}\n최대값: ${MAX_P2}\n최소값: ${MIN_P2}"

          # 3-1. 컴파일 시도
          if gcc main-2.c -o main2 2> compile_error_p2.txt; then
            echo -e "${GREEN}[OK]${NC} 문제 2: 컴파일 성공."

            # 3-2. 예상 출력 파일 생성
            printf "${EXPECTED_P2_LINES}\n" > expected_p2.txt

            # 3-3. 실행 및 원본 출력 캡처
            echo "$INPUT_P2" | ./main2 > actual_p2_raw.txt

            # 3-4. 출력 정리: 정답 키워드를 포함하는 라인들만 추출하고, 프롬프트 제거
            grep -E '합계:|최대값:|최소값:' actual_p2_raw.txt | \
              sed 's/^.*합계:/합계:/' | \
              sed 's/^.*최대값:/최대값:/' | \
              sed 's/^.*최소값:/최소값:/' > actual_p2.txt

            # 3-5. 출력 비교
            if [[ "$(normalize_output actual_p2.txt)" == "$(normalize_output expected_p2.txt)" ]]; then
              P2_SCORE=50
              P2_FEEDBACK="${GREEN}[OK]${NC} 문제 2 (합계, 최대/최소): 통과 (50점)"
            else
              P2_FEEDBACK="${RED}[FAIL]${NC} 문제 2 (합계, 최대/최소): 실패. (입력: ${INPUT_P2})"
              P2_FEEDBACK="${P2_FEEDBACK}\n  [학생 출력]: $(cat actual_p2.txt | tr '\n' ' ')"
              P2_FEEDBACK="${P2_FEEDBACK}\n  [예상 출력]: (정규화 전 - 출력 포맷 불일치 가능성)"
            fi
          else
            echo -e "${RED}[FAIL]${NC} 문제 2: 컴파일 실패."
            P2_FEEDBACK="${RED}[FAIL]${NC} 문제 2 (합계, 최대/최소): 컴파일 실패. 코드를 확인하세요."
          fi

          # ----------------------------------------------------
          # 4. 최종 점수 및 피드백 계산
          # ----------------------------------------------------
          FINAL_SCORE=$((P1_SCORE + P2_SCORE))
          
          # 최종 피드백 구성 (헤더 + P1 결과 + P2 결과)
          FULL_FEEDBACK="--- 최종 채점 결과 (총 ${FINAL_SCORE}점 / 100점) ---\n"
          FULL_FEEDBACK="${FULL_FEEDBACK}\n[문제 1 결과] ${P1_FEEDBACK}"
          FULL_FEEDBACK="${FULL_FEEDBACK}\n[문제 2 결과] ${P2_FEEDBACK}"
          
          # 5. GitHub Classroom 출력 (점수 및 피드백 전달)
          echo "점수: ${FINAL_SCORE} / 100"
          echo "피드백:\n"
          echo -e "$FULL_FEEDBACK"

          echo "score=$FINAL_SCORE" >> "$GITHUB_OUTPUT"
          echo "feedback<<EOF" >> "$GITHUB_OUTPUT"
          echo -e "$FULL_FEEDBACK" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          # 6. 최종 실패 보장 로직
          if [ $FINAL_SCORE -ne 100 ]; then
            echo "::error::[ERROR] 최종 점수가 100점이 아니므로 채점 실패 처리합니다."
            exit 1
          fi
